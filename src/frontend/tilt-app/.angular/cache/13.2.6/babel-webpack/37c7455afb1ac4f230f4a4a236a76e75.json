{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\shadow\\\\OneDrive\\\\Portofoliu\\\\TILT\\\\src\\\\frontend\\\\tilt-app\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\n\n/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { c as componentOnReady } from './helpers-4d272360.js';\nimport { a as printRequiredElementError } from './index-9ac92660.js';\nconst ION_CONTENT_TAG_NAME = 'ION-CONTENT';\nconst ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\nconst ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\n/**\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\n *\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\n * scroll events. With virtual scroll implementations this will be the host element for\n * the scroll viewport.\n */\n\nconst ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;\n\nconst isIonContent = el => el && el.tagName === ION_CONTENT_TAG_NAME;\n/**\n * Waits for the element host fully initialize before\n * returning the inner scroll element.\n *\n * For `ion-content` the scroll target will be the result\n * of the `getScrollElement` function.\n *\n * For custom implementations it will be the element host\n * or a selector within the host, if supplied through `scrollTarget`.\n */\n\n\nconst getScrollElement = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (el) {\n    if (isIonContent(el)) {\n      yield new Promise(resolve => componentOnReady(el, resolve));\n      return el.getScrollElement();\n    }\n\n    return el;\n  });\n\n  return function getScrollElement(_x) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Queries the element matching the selector for IonContent.\n * See ION_CONTENT_SELECTOR for the selector used.\n */\n\n\nconst findIonContent = el => {\n  /**\n   * First we try to query the custom scroll host selector in cases where\n   * the implementation is using an outer `ion-content` with an inner custom\n   * scroll container.\n   */\n  const customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\n\n  if (customContentHost) {\n    return customContentHost;\n  }\n\n  return el.querySelector(ION_CONTENT_SELECTOR);\n};\n/**\n * Queries the closest element matching the selector for IonContent.\n */\n\n\nconst findClosestIonContent = el => {\n  return el.closest(ION_CONTENT_SELECTOR);\n};\n/**\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\n * using the public API `scrollToTop` with a duration.\n */\n\n\nconst scrollToTop = (el, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollToTop(durationMs);\n  }\n\n  return Promise.resolve(el.scrollTo({\n    top: 0,\n    left: 0,\n    behavior: durationMs > 0 ? 'smooth' : 'auto'\n  }));\n};\n/**\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\n * using the public API `scrollByPoint` with a duration.\n */\n\n\nconst scrollByPoint = (el, x, y, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollByPoint(x, y, durationMs);\n  }\n\n  return Promise.resolve(el.scrollBy({\n    top: y,\n    left: x,\n    behavior: durationMs > 0 ? 'smooth' : 'auto'\n  }));\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\n */\n\n\nconst printIonContentErrorMsg = el => {\n  return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\n};\n\nexport { findClosestIonContent as a, scrollByPoint as b, findIonContent as f, getScrollElement as g, isIonContent as i, printIonContentErrorMsg as p, scrollToTop as s };","map":{"version":3,"sources":["C:/Users/shadow/OneDrive/Portofoliu/TILT/src/frontend/tilt-app/node_modules/@ionic/core/dist/esm/index-7cd5eefa.js"],"names":["c","componentOnReady","a","printRequiredElementError","ION_CONTENT_TAG_NAME","ION_CONTENT_ELEMENT_SELECTOR","ION_CONTENT_CLASS_SELECTOR","ION_CONTENT_SELECTOR","isIonContent","el","tagName","getScrollElement","Promise","resolve","findIonContent","customContentHost","querySelector","findClosestIonContent","closest","scrollToTop","durationMs","content","scrollTo","top","left","behavior","scrollByPoint","x","y","scrollBy","printIonContentErrorMsg","b","f","g","i","p","s"],"mappings":"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","sourcesContent":["/*!\n * (C) Ionic http://ionicframework.com - MIT License\n */\nimport { c as componentOnReady } from './helpers-4d272360.js';\nimport { a as printRequiredElementError } from './index-9ac92660.js';\n\nconst ION_CONTENT_TAG_NAME = 'ION-CONTENT';\nconst ION_CONTENT_ELEMENT_SELECTOR = 'ion-content';\nconst ION_CONTENT_CLASS_SELECTOR = '.ion-content-scroll-host';\n/**\n * Selector used for implementations reliant on `<ion-content>` for scroll event changes.\n *\n * Developers should use the `.ion-content-scroll-host` selector to target the element emitting\n * scroll events. With virtual scroll implementations this will be the host element for\n * the scroll viewport.\n */\nconst ION_CONTENT_SELECTOR = `${ION_CONTENT_ELEMENT_SELECTOR}, ${ION_CONTENT_CLASS_SELECTOR}`;\nconst isIonContent = (el) => el && el.tagName === ION_CONTENT_TAG_NAME;\n/**\n * Waits for the element host fully initialize before\n * returning the inner scroll element.\n *\n * For `ion-content` the scroll target will be the result\n * of the `getScrollElement` function.\n *\n * For custom implementations it will be the element host\n * or a selector within the host, if supplied through `scrollTarget`.\n */\nconst getScrollElement = async (el) => {\n  if (isIonContent(el)) {\n    await new Promise((resolve) => componentOnReady(el, resolve));\n    return el.getScrollElement();\n  }\n  return el;\n};\n/**\n * Queries the element matching the selector for IonContent.\n * See ION_CONTENT_SELECTOR for the selector used.\n */\nconst findIonContent = (el) => {\n  /**\n   * First we try to query the custom scroll host selector in cases where\n   * the implementation is using an outer `ion-content` with an inner custom\n   * scroll container.\n   */\n  const customContentHost = el.querySelector(ION_CONTENT_CLASS_SELECTOR);\n  if (customContentHost) {\n    return customContentHost;\n  }\n  return el.querySelector(ION_CONTENT_SELECTOR);\n};\n/**\n * Queries the closest element matching the selector for IonContent.\n */\nconst findClosestIonContent = (el) => {\n  return el.closest(ION_CONTENT_SELECTOR);\n};\n/**\n * Scrolls to the top of the element. If an `ion-content` is found, it will scroll\n * using the public API `scrollToTop` with a duration.\n */\nconst scrollToTop = (el, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollToTop(durationMs);\n  }\n  return Promise.resolve(el.scrollTo({\n    top: 0,\n    left: 0,\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\n  }));\n};\n/**\n * Scrolls by a specified X/Y distance in the component. If an `ion-content` is found, it will scroll\n * using the public API `scrollByPoint` with a duration.\n */\nconst scrollByPoint = (el, x, y, durationMs) => {\n  if (isIonContent(el)) {\n    const content = el;\n    return content.scrollByPoint(x, y, durationMs);\n  }\n  return Promise.resolve(el.scrollBy({\n    top: y,\n    left: x,\n    behavior: durationMs > 0 ? 'smooth' : 'auto',\n  }));\n};\n/**\n * Prints an error informing developers that an implementation requires an element to be used\n * within either the `ion-content` selector or the `.ion-content-scroll-host` class.\n */\nconst printIonContentErrorMsg = (el) => {\n  return printRequiredElementError(el, ION_CONTENT_ELEMENT_SELECTOR);\n};\n\nexport { findClosestIonContent as a, scrollByPoint as b, findIonContent as f, getScrollElement as g, isIonContent as i, printIonContentErrorMsg as p, scrollToTop as s };\n"]},"metadata":{},"sourceType":"module"}